 -------------------------------
|                               |
|     jMetalCpp - README        |
|                               |
 -------------------------------

=======================================================================================
TABLE OF CONTENTS
=======================================================================================
0. Requirements
1. Installing jMetalCpp
2. Executing jMetalCpp
3. Choosing a problem
4. Configuring a problem
5. Calculating quality indicators (NEW)
6. Advanced: Building a Experiment (NEW)
  6.1. Executing a experiment (NEW)
  6.2. Generating reports from a experiment (NEW) 
=======================================================================================


=======================================================================================
0. Requirements
=======================================================================================

jMetalCpp has been developed in Unix machines (Ubuntu and MacOS X) as well as in
Windows (Cygwin) using the G++ compiler. The make utility has been used to compile the
software package.

=======================================================================================


=======================================================================================
1. Installing jMetalCpp
=======================================================================================

Copy the compressed file to the location where you want to install jMetal and
unzip it.

Then, compile the code with the following command:
	% make

=======================================================================================


=======================================================================================	
2. Executing jMetal
=======================================================================================

All the binaries are in the 'bin' folder. Enter the folder to execute jMetal.
	
	% cd bin

The following multi-objective metaheuristics are provided in this version of jMetal:

	Algorithm                                   Command
	---------------------------------------------------------
	NSGA-II                                     NSGAII_main
	GDE3                                        GDE3_main
	SMPSO                                       SMPSO_main
	
Additionally, we include single-objective variants of these techniques:

	Algorithm                                   Command
	---------------------------------------------------------
	DE (Differential Evolution)                 DE_main
	gGA (Generational Genetic Algorithm)        gGA_main
	PSO (Particle Swarm Optimization)           PSO_main
	ssGA (Steady-state Genetic Algorithm)       ssGA_main
	
To execute one metaheuristic just use its associated command. For example, to execute
GDE3 use the following command:
	
	% ./GDE3_main

=======================================================================================


=======================================================================================
3. Choosing a problem
=======================================================================================

If you execute an algorithm like before, a default problem will be used for each
algorithm. You can specify what problem to solve by passing it as a parameter. For
example, if you desire to execute the Generational Genetic Algorithm to solve the
Sphere problem, you need to execute the following command:
	
	% ./gGA_main Sphere
	
The following problems are currently included:
	- Fonseca
	- Kursawe
	- OneMax
	- Schaffer
	- Sphere
	- DTLZ1
	- DTLZ2
	- DTLZ3
	- DTLZ4
	- DTLZ5
	- DTLZ6
	- DTLZ7
	- ZDT1
	- ZDT2
	- ZDT3
	- ZDT4
	- ZDT5
	- ZDT6

=======================================================================================


=======================================================================================
4. Configuring a problem
=======================================================================================

When you select a problem to solve, you can configure some problem parameters passing
them as parameters. If a problem has three parameters, you can choose to specify one,
two or the three of them.

The following parameters can be configured when going to solve a problem:

 Problem        Parameter 1         Parameter 2             Parameter 3
--------------------------------------------------------------------------------------
 Fonseca        Solution type
 Kursawe        Solution type       Number of variables
 OneMax         Number of bits      Number of strings
 Shaffer        Solution type
 Sphere         Solution type       Number of variables
 DTLZ1          Solution type       Number of variables     Number of objectives
 DTLZ2          Solution type       Number of variables     Number of objectives
 DTLZ3          Solution type       Number of variables     Number of objectives
 DTLZ4          Solution type       Number of variables     Number of objectives
 DTLZ5          Solution type       Number of variables     Number of objectives
 DTLZ6          Solution type       Number of variables     Number of objectives
 DTLZ7          Solution type       Number of variables     Number of objectives
 ZDT1           Solution type       Number of variables
 ZDT2           Solution type       Number of variables
 ZDT3           Solution type       Number of variables
 ZDT4           Solution type       Number of variables
 ZDT5           Solution type       Number of variables
 ZDT6           Solution type       Number of variables

The following values are allowed for the 'Solution type' parameter:
	- Real
	- Binary
	
For example, if you wanted to solve the DTLZ5 problem using SMPSO using 'Real" as
solution type, you would need to execute the following command:
	
	% ./SMPSO_main DTLZ5 Real
	
If you wanted to modify the default parameters and use ten variables and two objectives,
you would need to execute the following command:
	
	%./SMPSO_main DTLZ5 Real 10 2

=======================================================================================


=======================================================================================
5. Calculating quality indicators (NEW)
=======================================================================================

It is possible to calculate quality indicators for your execution results.

The following quality indicators are are provided in this version of jMetal:

	Quality Indicator                     Command
	---------------------------------------------------------------------
	Hypervolume                           Hypervolume
	Spread                                Spread
	Epsilon                               Epsilon
	Generational Distance                 GenerationalDistance
	Inverted Generational Distance        InvertedGenerationalDistance
	
You need optimal pareto fronts file to calculate each quality indicator. You can
download them from http://jmetal.sourceforge.net/problems.html

To calculate a quality indicator you will need to execute the following command:

	% ./<QualityIndicatorCommand> <SolutionFrontFile> <TrueFrontFile>
		<numberOfObjectives>

For example, if you wanted to calculate the hypervolume indicator for the ZDT1 problem,
you would have to execute the following command:

	% ./Hypervolume /home/username/jmetalcpp-test/FUN
		/home/username/jmetalcpp-test/ZDT1.pf 2
		
Remember to change the file paths to whatever your actual locations are.
		
=======================================================================================


=======================================================================================
6. Advanced: Building a Experiment (NEW)
=======================================================================================

Since this version of jMetalCpp, it is possible to create experiments. A experiment is
a list of algorithms and problems to be executed concurrently. Using experiments, it is
now possible to have a larger set of results in less time.

Experiments are divided in two independent parts: an execution part and a report part.

The execution part is the one which executes all the problems using the selected
algorithms. Each problem will be executed a specified number of times. The algorithms
will be executed concurrently by a specified number of threads.

The report part generates quality indicators to measure the quality of the result
data, and calculate some statistical data. These statistics are presented in tables
using the latex language and boxplot charts using R scripts.

=======================================================================================


=======================================================================================
  6.1. Executing a experiment (NEW)
=======================================================================================

To execute the 'execution part' of a experiment, you only need to execute the
corresponding command. This version of jMetalCpp provides two already implemented
experiments. Feel free to edit these experiments or create new ones. Remember that
after editing the code, you will have to compile the code again.

The two provided experiments are:
	- StandardStudyExecution
	- StandardStudyExecutionSO
	
The first one is a multi-objective experiment. The second one is a single-objective
one. In order to execute a experiment, you only have to enter its corresponding command.
For example:

	% ./StandardStudyExecution
	
Before executing them (and compile them), it is important to change some parameters in
the code. Most important, you will have to edit the paths where to store the output
files and from where to read the input files. You will have to edit the corresponding
cpp files located in the 'jmetalcpp/src/experiments/' folder.

In each cpp file, you can edit the following parameters:

	- experimentName:
		Self-explanatory. It will be used to create a folder when to store the
		results.
		
	- algorithmNameList:
		List of algorithms to be executed for each problem in the experiment.
		
	- problemList:
		List of problems that will be resolved in the experiment.
		
	- independentRuns:
		Number of times that each problem will be executed for each algorithm.
		
	- numberOfThreads:
		Number of threads that will be used to execute the algorithms concurrently.
		
	- experimentBaseDirectory:
		Directory path where all the experiments result will be	stored. Inside this
		folder, the following structure will be created:
		
			- <base_directory>
				|-data
					|- <algorithm_1>
					|	|- <problem_1>
					|	|	Result files from problem 1 using algorithm 1.
					|	|	(FUN.1, FUN.2, ..., FUN.X, VAR.1, VAR.2, ..., VAR.X)
					|	|- <problem_2>
					|	|	Result files from problem 2 using algorithm 1.
					|	|	(FUN.1, FUN.2, ..., FUN.X, VAR.1, VAR.2, ..., VAR.X)	
					|	|- ...
					|	|- <problem_n>
					|		Result files from problem n using algorithm 1.
					|		(FUN.1, FUN.2, ..., FUN.X, VAR.1, VAR.2, ..., VAR.X)
					|
					|- <algorithm_2>
					|	|- <problem_1>
					|	|	Result files from problem 1 using algorithm 2.
					|	|- <problem_2>
					|	|	Result files from problem 2 using algorithm 2.
					|	|- ...
					|	|- <problem_n>
					|		Result files from problem n using algorithm 2.
					|
					|- ...
					|
					|- <algorithm_m>
						|- <problem_1>
						|	Result files from problem 1 using algorithm m.
						|- <problem_2>
						|	Result files from problem 2 using algorithm m.	
						|- ...
						|- <problem_n>
							Result files from problem n using algorithm m.
							
Each algorithm used in the execution must be configured. This is done in the
algorithmSettings method in each cpp file. For each algorithm (NSGAII, GDE3, gGA...),
this version of jMetalCpp provides a Settings class with default configuration. You can
edit this Setting classes to change the algorithm parameters. Don't forget to edit the
algorithmSettings to configure each algorithm used in the experiment. It's possible to
execute the same algorithm more than once in a experiment with different
configurations, but you will have to implement a Settings class for each variance of
the algorithm.

=======================================================================================


=======================================================================================
  6.2. Generating reports from a experiment (NEW) 
=======================================================================================

To execute the 'report part' of a experiment, you only need to execute the
corresponding command. For this part, this version of jMetalCpp provides three already
implemented experiments. The first two generate reports for the multi-objective
experiment and the other one generate reports for the single-objective one. Feel free
to edit these experiments or create new ones. Remember that after editing the code, you
will have to compile the code again.

The three provided experiments are:
	- StandardStudyReportPF
	- StandardStudyReportRF
	- StandardStudyReportSO
	
The difference between StandardStudyReportPF and StandardStudyReportRF is the use of
known optimal pareto fronts to calculate the quality indicators. The first one uses
them, and the second one suppose that the pareto fronts are unknown and will generate
some reference fronts in order to be able to calculate the indicators.
StandardStudyReportSO generates the reports for the single-objective experiment.

In order to execute a experiment report, you only have to enter its corresponding
command. For example:

	% ./StandardStudyReportPF
	
Before executing them (and compile them), it is important to change some parameters in
the code. Most important, you will have to edit the paths where to store the output
files and from where to read the input files. You will have to edit the corresponding
cpp files located in the 'jmetalcpp/src/experiments/' folder.

In each cpp file, you can edit the following parameters:

	- experimentName:
		Self-explanatory. It will be used to know the folder from where to read the
		execution results.
		
	- algorithmNameList:
		List of algorithms which were executed for each problem in the experiment
		execution part.
		
	- problemList:
		List of problems which were resolved in the experiment execution part.
		
	- independentRuns:
		Number of times that each problem were executed for each algorithm in the
		execution part.
		
	- experimentBaseDirectory:
		Directory path where all the experiments result were stored.
	
	- indicatorList:
		List of quality indicators that will be calculated in the reports. When doing
		a experiment about single-objective algorithms, the only possible value is
		"FIT".
		
	- paretoFrontFile:
		List of optimal pareto front files that will be used to calculate the
		quality indicators. Only necessary if the optimal pareto fronts are known and
		if the experiment is about multi-objective algorithms.
		
	- paretoFrontDirectory:
		Directory path when the optimal pareto fronts are stored. Only necessary when
		going to use known optimal pareto fronts. If it is a single-objective
		experiment, this parameter is not used. If it is a multi-objective experiment
		and this parameter is not especified, reference pareto fronts will be
		generated to calculate the quality indicators.

=======================================================================================
